%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}


\setmainfont{TeX Gyre Termes}
\setsansfont{TeX Gyre Termes}
\setmonofont{DejaVu Sans Mono}

\usepackage[Bjornstrup]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage[vmargin=2.5cm, hmargin=3cm]{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\usepackage[titles]{tocloft}
\cftsetpnumwidth {1.25cm}\cftsetrmarg{1.5cm}
\setlength{\cftchapnumwidth}{0.75cm}
\setlength{\cftsecindent}{\cftchapnumwidth}
\setlength{\cftsecnumwidth}{1.25cm}

\title{inknest}
\date{Aug 31, 2021}
\release{1.0}
\author{Gianluca Becuzzi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Generated code description}
\label{\detokenize{autogen:generated-code-description}}\label{\detokenize{autogen::doc}}
Code description generated automatically from docstrings.


\section{model.py}
\label{\detokenize{autogen:module-model}}\label{\detokenize{autogen:model-py}}\index{module@\spxentry{module}!model@\spxentry{model}}\index{model@\spxentry{model}!module@\spxentry{module}}\index{Model (class in model)@\spxentry{Model}\spxextra{class in model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{model.}}\sphinxbfcode{\sphinxupquote{Model}}}{\emph{\DUrole{n}{log\_prior}}, \emph{\DUrole{n}{log\_likelihood}}, \emph{\DUrole{n}{space\_bounds}}}{}
Class to describe models
\index{log\_prior (model.Model attribute)@\spxentry{log\_prior}\spxextra{model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.log_prior}}\pysigline{\sphinxbfcode{\sphinxupquote{log\_prior}}}
the logarithm of the prior pdf
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{log\_likelihood (model.Model attribute)@\spxentry{log\_likelihood}\spxextra{model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.log_likelihood}}\pysigline{\sphinxbfcode{\sphinxupquote{log\_likelihood}}}
the logarithm of the likelihood function
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{space\_bounds (model.Model attribute)@\spxentry{space\_bounds}\spxextra{model.Model attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.space_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{space\_bounds}}}
the coordinate of the two vertices of the hyperrectangle
defining the bounds of the parameters
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
2\sphinxhyphen{}tuple of \sphinxcode{\sphinxupquote{np.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}


\begin{sphinxadmonition}{note}{Note:}
The log\_prior and logg\_likelihood functions are user defined and must have \sphinxstylestrong{one argument only}.

They also must be capable of managing (*,*, .., space\_dimension )\sphinxhyphen{}shaped arrays,
so make sure every operation is done on the \sphinxstylestrong{\sphinxhyphen{}1 axis of input}.

If input is a single point of shape (space\_dimension,) both the functions
must return a float ( not a (1,)\sphinxhyphen{}shaped array )
\end{sphinxadmonition}
\index{\_\_init\_\_() (model.Model method)@\spxentry{\_\_init\_\_()}\spxextra{model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{log\_prior}}, \emph{\DUrole{n}{log\_likelihood}}, \emph{\DUrole{n}{space\_bounds}}}{}
Initialise the sampler.

By default the starting point of the markov chain are uniformly distributed over all space.

\end{fulllineitems}

\index{is\_inside\_bounds() (model.Model method)@\spxentry{is\_inside\_bounds()}\spxextra{model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.is_inside_bounds}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_inside\_bounds}}}{\emph{\DUrole{n}{points}}}{}
Checks if a point is inside the space bounds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) – point to be checked. Must have shape (*,space\_dim,).

\item[{Returns}] \leavevmode

True if all the coordinates lie between bounds
\begin{quote}

False if at least one is outside.

The returned array has shape (*,) = \sphinxcode{\sphinxupquote{utils.pointshape(point)}}
\end{quote}


\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{log\_chi() (model.Model method)@\spxentry{log\_chi()}\spxextra{model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.log_chi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{log\_chi}}}{\emph{\DUrole{n}{points}}}{}
Logarithm of the characteristic function of the domain.
Is equivalent to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{is\PYGZus{}inside\PYGZus{}bounds}\PYG{p}{(}\PYG{n}{point}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) – point to be checked. Must have shape (*,space\_dim,).

\item[{Returns}] \leavevmode

0 if all the coordinates lie between bounds
\begin{quote}

\sphinxhyphen{}\sphinxcode{\sphinxupquote{np.inf}} if at least one is outside

The returned array has shape (*,) = \sphinxcode{\sphinxupquote{utils.pointshape(point)}}
\end{quote}


\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{new\_is\_inside\_bounds() (model.Model method)@\spxentry{new\_is\_inside\_bounds()}\spxextra{model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.new_is_inside_bounds}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{new\_is\_inside\_bounds}}}{\emph{\DUrole{n}{points}}}{}
Same as \sphinxcode{\sphinxupquote{is\_inside\_bounds}}.

Shorter but slower (allegedly due to high processing time of numpy broadcasting).

\end{fulllineitems}

\index{pointshape() (model.Model method)@\spxentry{pointshape()}\spxextra{model.Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.Model.pointshape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pointshape}}}{\emph{\DUrole{n}{x}}}{}
\sphinxcode{\sphinxupquote{self}} shorthand for \sphinxcode{\sphinxupquote{utils.pointshape(x, dim = self.space\_dim)}}

\end{fulllineitems}


\end{fulllineitems}

\index{unpack\_variables() (in module model)@\spxentry{unpack\_variables()}\spxextra{in module model}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:model.unpack_variables}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{model.}}\sphinxbfcode{\sphinxupquote{unpack\_variables}}}{\emph{\DUrole{n}{x}}}{}
Helper function that performs values shapecasting.

Given a \sphinxcode{\sphinxupquote{np.ndarray}} of shape \sphinxcode{\sphinxupquote{(n1,n2,\sphinxhyphen{}\sphinxhyphen{}, space\_dim)}}
returns an unpackable array of shape \sphinxcode{\sphinxupquote{(space\_dim, n1,n2, \sphinxhyphen{}\sphinxhyphen{})}}.

\begin{sphinxadmonition}{note}{Note:}
if any of the n1, n2, – other dimension is equal to one,
it gets squeezed as it is an unnecessary nesting.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) – the array to be casted

\item[{Returns}] \leavevmode
an unpackable array

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}
\subsubsection*{Example}

It can be used to define models:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{log\PYGZus{}prior}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{unpack\PYGZus{}variables}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{return} \PYG{n}{x1}\PYG{o}{/}\PYG{n}{x2}\PYG{o}{*}\PYG{n}{x3}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
It may be computationally expensive. Check for improvements.
\end{sphinxadmonition}

\end{fulllineitems}



\section{samplers.py}
\label{\detokenize{autogen:module-samplers}}\label{\detokenize{autogen:samplers-py}}\index{module@\spxentry{module}!samplers@\spxentry{samplers}}\index{samplers@\spxentry{samplers}!module@\spxentry{module}}
Module containing the samplers used in main calculations.

Since almost every sampler is defined by a markov chain, basic attributes are
the model and the length of the chain.

Each sampler shoud be capable of tackling with discontinuous functions.

Since is intended to be used in nested sampling, each sampler should support likelihood constrained prior sampling (LCPS).
\index{AIESampler (class in samplers)@\spxentry{AIESampler}\spxextra{class in samplers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.AIESampler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{samplers.}}\sphinxbfcode{\sphinxupquote{AIESampler}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{mcmc\_length}}, \emph{\DUrole{n}{nwalkers}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{space\_scale}\DUrole{o}{=}\DUrole{default_value}{4}}, \emph{\DUrole{n}{verbosity}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
The Affine\sphinxhyphen{}Invariant Ensemble sampler (Goodman, Weare, 2010).

After a uniform initialisation step, for each particle k selects a \sphinxstyleemphasis{pivot} particle an then proposes
\begin{align*}\!\begin{aligned}
j = k + random(0 \rightarrow n)\\
z \char`~ g(z)\\
y = x_j + z (x_k - x_j)\\
\end{aligned}\end{align*}
and then executes a MH\sphinxhyphen{}acceptance over y (more information at <\sphinxurl{https://msp.org/camcos/2010/5-1/camcos-v5-n1-p04-p.pdf}>).
\index{\_\_init\_\_() (samplers.AIESampler method)@\spxentry{\_\_init\_\_()}\spxextra{samplers.AIESampler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.AIESampler.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{mcmc\_length}}, \emph{\DUrole{n}{nwalkers}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{space\_scale}\DUrole{o}{=}\DUrole{default_value}{4}}, \emph{\DUrole{n}{verbosity}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
Initialise the chain uniformly over the space bounds.

\end{fulllineitems}

\index{get\_stretch() (samplers.AIESampler method)@\spxentry{get\_stretch()}\spxextra{samplers.AIESampler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.AIESampler.get_stretch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_stretch}}}{\emph{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Generates the stretch values given the scale\_parameter \sphinxcode{\sphinxupquote{a}}.

Output is distibuted as \(\frac{1}{\sqrt{z}}\)  in \([1/a,a]\).
Uses inverse transform sampling

\end{fulllineitems}

\index{join\_chains() (samplers.AIESampler method)@\spxentry{join\_chains()}\spxextra{samplers.AIESampler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.AIESampler.join_chains}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{join\_chains}}}{\emph{\DUrole{n}{burn\_in}\DUrole{o}{=}\DUrole{default_value}{0.02}}}{}
Joins the chains for the ensemble after removing  \sphinxcode{\sphinxupquote{burn\_in}} \% of each single\_particle chain.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{burn\_in}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) – 
the burn\_in percentage.

Must be \sphinxcode{\sphinxupquote{burn\_in}} > 0 and \sphinxcode{\sphinxupquote{burn\_in}} < 1.


\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_prior() (samplers.AIESampler method)@\spxentry{sample\_prior()}\spxextra{samplers.AIESampler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.AIESampler.sample_prior}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_prior}}}{}{}
Samples prior.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the chain obtained

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Sampler (class in samplers)@\spxentry{Sampler}\spxextra{class in samplers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.Sampler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{samplers.}}\sphinxbfcode{\sphinxupquote{Sampler}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{mcmc\_length}}, \emph{\DUrole{n}{nwalkers}}, \emph{\DUrole{n}{verbosity}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
Produces samples from model.

It is intended as a base class that has to be further defined.
For generality the attribute \sphinxtitleref{nwalkers} is present, but it can be one for not ensamble\sphinxhyphen{}based samplers.
\index{model (samplers.Sampler attribute)@\spxentry{model}\spxextra{samplers.Sampler attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.Sampler.model}}\pysigline{\sphinxbfcode{\sphinxupquote{model}}}
Model defined as the set of (log\_prior, log\_likelihood , bounds)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{autogen:model.Model}]{\sphinxcrossref{model.Model}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mcmc\_lenght (samplers.Sampler attribute)@\spxentry{mcmc\_lenght}\spxextra{samplers.Sampler attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.Sampler.mcmc_lenght}}\pysigline{\sphinxbfcode{\sphinxupquote{mcmc\_lenght}}}
the lenght of the single markov chain
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{nwalkers (samplers.Sampler attribute)@\spxentry{nwalkers}\spxextra{samplers.Sampler attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.Sampler.nwalkers}}\pysigline{\sphinxbfcode{\sphinxupquote{nwalkers}}}
the number of walkers the ensamble is made of
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (samplers.Sampler method)@\spxentry{\_\_init\_\_()}\spxextra{samplers.Sampler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:samplers.Sampler.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{mcmc\_length}}, \emph{\DUrole{n}{nwalkers}}, \emph{\DUrole{n}{verbosity}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
Initialise the chain uniformly over the space bounds.

\end{fulllineitems}


\end{fulllineitems}



\section{utils.py}
\label{\detokenize{autogen:module-utils}}\label{\detokenize{autogen:utils-py}}\index{module@\spxentry{module}!utils@\spxentry{utils}}\index{utils@\spxentry{utils}!module@\spxentry{module}}\index{logsubexp() (in module utils)@\spxentry{logsubexp()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:utils.logsubexp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{logsubexp}}}{\emph{\DUrole{n}{x1}}, \emph{\DUrole{n}{x2}}}{}
Helper function to execute \(\log{(e^{x_1} - e^{x_2})}\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) – 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x2}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) – 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{logsumexp() (in module utils)@\spxentry{logsumexp()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:utils.logsumexp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{logsumexp}}}{\emph{\DUrole{n}{arg}}}{}
Utility to sum over log\_values.
Given a  vector {[}a1,a2,a3, … {]} returns \(\log{(e^{a1} + e^{a2} + ...)}\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{arg}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) – the array of values to be log\sphinxhyphen{}sum\sphinxhyphen{}exponentiated

\item[{Returns}] \leavevmode
\(\log{(e^{a1} + e^{a2} + ...)}\)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{pointshape() (in module utils)@\spxentry{pointshape()}\spxextra{in module utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{autogen:utils.pointshape}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.}}\sphinxbfcode{\sphinxupquote{pointshape}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Gives the shape of an array of points of dimension \sphinxcode{\sphinxupquote{space\_dim}}.
Basically pops the last item of \sphinxcode{\sphinxupquote{x.shape}} and checks whether it’s fine.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) – 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxcode{\sphinxupquote{int}}, optional) – the space dimension

\end{itemize}

\item[{Returns}] \leavevmode
the shape of x considering last axis made of ()\sphinxhyphen{}shaped items.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{model}\sphinxstyleindexpageref{autogen:\detokenize{module-model}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{samplers}\sphinxstyleindexpageref{autogen:\detokenize{module-samplers}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utils}\sphinxstyleindexpageref{autogen:\detokenize{module-utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\footnotesize\raggedright\printindex
\end{document}